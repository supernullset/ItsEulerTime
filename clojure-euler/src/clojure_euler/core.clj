(ns clojure-euler.core
  (:require [clojure.core.matrix :as m])
  (:require [criterium.core])
  (:require [clojure.core.reducers :as r]))


(defn zero-zero-one
  "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000."
  []
  (let [
        div-by-three #(= 0 (mod %1 3))
        div-by-five #(= 0 (mod %1 5))
        multiples (for [index (range 1 1000)]
                    (if (or (div-by-five index) (div-by-three index)) index)
                    )]
    (reduce + (filter (comp not nil?) multiples))
    )
  ;; ANS => 233168
  )


;; using r/fold is faster than reduce. TODO: Investigate why
(defn fib-at-n
  "closed form matrix solution for fibonacci numbers"
  [n reducer]
  (let [
        fib-matrix (m/matrix [[1N 1N] [1N 0N]])
        computed   (reducer m/mmul (repeat n fib-matrix))
        fib-n      (get-in computed [1 1])
        fib-n-plus (get-in computed [1 0])
        fibs       (list fib-n fib-n-plus)
        ]
    fibs))

(defn fibs
  "get list of all fibonacci numbers unil n"
  [n]
  (let [
        r (range 3 n 2)
        fibs (flatten (map fib-at-n r))
        ]
    fibs))

(defn zero-zero-two
  "Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."
  (reduce + (filter even? (filter #(< %1 4000000) (fibs 100))))
  ;; => 4613732
  )
